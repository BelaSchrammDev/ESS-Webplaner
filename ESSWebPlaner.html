<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ESS Web Planer</title>
    <style>
        :root {
            --filter_height: 50px;
            --list_margin_top: 100px;

            --button_bar_left_width: 120px;
        }

        .hide {
            display: none;
        }

        /* ------------------------------------------------------ */

        .button_bar_left {
            position: fixed;
            left: 0;
            top: var(--filter_height);
            bottom: 0;
            background-color: bisque;
            width: var(--button_bar_left_width);
            display: flex;
            flex-direction: column;
            justify-content: flex-start;
            align-items: stretch;
            gap: 10px;
            padding-top: 50px;
            padding-left: 10px;
            padding-right: 10px;
        }

        .button_bar_left button {
            border-radius: 10px;
        }

        .button_bar_left span {
            text-align: center;
        }

        /* ------------------------------------------------------ */

        .list_content {
            margin-top: var(--list_margin_top);
            width: max-content;
            padding-left: var(--button_bar_left_width);
            margin-left: auto;
            margin-right: auto;
        }

        table,
        th,
        td {
            border-collapse: collapse;
        }

        /* ------------------------------------------------------ */

        .table_main th {
            height: 40px;
            text-wrap: wrap;
            padding-left: 10px;
            padding-right: 10px;
            text-align: center;
            vertical-align: bottom;
            color: green;
        }

        .table_main td {
            border: 1px solid black;
            text-align: center;
        }

        /* ------------------------------------------------------ */

        .table_week th {
            font-size: 50px;
            font-weight: 1000;
            text-align: center;
            vertical-align: middle;
            color: green;
        }

        .table_week td:nth-child(1) {
            border: 4px solid black;
            text-align: right;
            font-size: 40px;
            font-weight: 1000;
        }

        .table_week td:nth-child(1n+2) {
            width: 150px;
            height: 70px;
            border: 4px solid black;
            text-align: left;
            font-size: 30px;
            font-weight: 1000;
            padding-left: 20px;
        }

        /* ------------------------------------------------------ */
        .filters {
            padding-left: 50px;
            padding-right: 50px;
            background-color: gray;
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            height: var(--filter_height);
            display: flex;
            justify-content: space-between;
            align-items: center;
            gap: 10px;
            min-width: 900px;
        }

        .filters span {
            color: black;
            font-weight: bold;
            background-color: lightgray;
            padding: 5px;
            border-radius: 5px;
        }

        .filter_infos {
            display: flex;
            justify-content: space-between;
            align-items: center;
            gap: 10px;
            flex-grow: 1;
        }

        .file_choise {
            padding: 10px;
            border: 2px solid green;
            border-radius: 5px;
            background-color: gray;
            margin: auto;
            height: max-content;
            width: max-content;
        }

        /* ------------------------------------------------------ */

        .changegewindetype {
            position: fixed;
            left: 0;
            top: 0;
            left: 0;
            right: 0;
            z-index: 10;
            height: 100vh;
            width: 100vw;
            background-color: rgba(0, 0, 0, 0.5);
        }

        .change_gt_innerbox {
            position: absolute;
            left: 0;
            top: 0;
            left: 0;
            right: 0;
            z-index: 20;
            height: 100vh;
            width: 100vw;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        .change_gt_actions {
            display: flex;
            justify-content: space-between;
        }

        .change_gt_box {
            height: max-content;
            width: max-content;
            background-color: lightgray;
            border-radius: 10px;
            padding: 20px;
            border: 4px solid orange;
            display: flex;
            flex-direction: column;
            justify-content: flex-start;
            align-items: stretch;
            gap: 10px;
        }

        /* ------------------------------------------------------ */

        @media print {
            .list_type {
                display: block;
            }

            .button_bar_left {
                display: none;
            }

            .button_bar_right {
                display: none;
            }

            .filters {
                position: unset;
                min-width: unset;
                /* width: 600px; */
            }

            .list_content {
                margin-top: 0;
                padding-left: 0;
            }

            .table_main th:last-child,
            .table_main td:last-child {
                display: none;
            }

            body {
                print-color-adjust: exact;
                -webkit-print-color-adjust: exact;
            }
        }
    </style>
    <script>
        const tableHeaderStrings = {
            "ZU_AUFTRAG": "Kd.Auftrag",
            "T_R": "Termin<br>Rohlinge",
            "ABMESSUNG": "Abmessung von CPU",
            "ABMESSUNG_PUR": "Abmessung",
            "T_LAEPP": "Termin<br>Läppdorne",
            "KUNDE": "Kundennummer",
            "HINWEISTEXT": "Hinweis",
            "SUCHNAME": "Kennzahlen",
            "NETTOSUMME": "Nettosumme",
            "BELEGDATUM": "Belegdatum",
            "NUMMER": "ESS<br>Auftrags<br>Nummer",
            "KENNWORT": "Kennwort",
            "ROHTEILDURCHMESSER": "Rohteil<br>&Oslash;",
            "LDROHDURCHMESSER": "Läppdorn<br>Roh<br>Material",
            "LDBOHRDURCHMESSER": "Läppdorn<br>Bohrung<br>&Oslash;",
            "STATUS": "steht bei...",
            "LAEPPDATE": "Läppdatum",
            "ROHTEILDATE": "Rohlingsdatum",
            "ROHTEILWOCHE": "Wochen<br>termin<br>Rohling",
            "BELEGDATE": "Belegdatum",
            "KENNWORT_CPU": "Kennwort CPU",
            "NENNDURCHMESSER": "Gewinde<br>nenn<br>&Oslash;",
            "STEIGUNG": "Steigung",
            "GEWINDETYPE": "Type",
        };

        const tableViewAllKeys = ['NUMMER', 'ROHTEILDURCHMESSER', 'ABMESSUNG_PUR', 'GEWINDETYPE', 'NENNDURCHMESSER', 'STEIGUNG', 'T_R', 'T_LAEPP', 'STATUS', 'KENNWORT',];
        const tableViewRohteilKeys = ['NUMMER', 'ROHTEILDURCHMESSER', 'ABMESSUNG_PUR', 'T_R', 'ROHTEILWOCHE', 'KENNWORT',];
        const tableViewLaeppdornKeys = ['NUMMER', 'ROHTEILDURCHMESSER', 'LDROHDURCHMESSER', 'LDBOHRDURCHMESSER', 'GEWINDETYPE', 'ABMESSUNG_PUR', 'NENNDURCHMESSER', 'STEIGUNG', 'T_LAEPP', 'KENNWORT'];
        const tableViewLaeppKeys = ['NUMMER', 'ROHTEILDURCHMESSER', 'ABMESSUNG_PUR', 'GEWINDETYPE', 'NENNDURCHMESSER', 'STEIGUNG', 'T_R', 'T_LAEPP', 'KENNWORT'];

        let dateCPUTable = new Date();
        let tableCPU = [];
        let tableCPU_Fields = [];
        let editGT_ID = -1;
        let lastRenderType = undefined;


        function loadTable(inputField) {
            const jsonTableObject = inputField.files[0];
            dateCPUTable = new Date(jsonTableObject.lastModified);
            document.getElementById('lastModifiedDate').innerHTML = `${dateCPUTable.toLocaleString()}`;
            const reader = new FileReader();
            reader.onload = (evt) => {
                parseTable(evt.target.result);
            }
            reader.readAsText(jsonTableObject);
        }


        function parseTable(tableJSON) {
            document.getElementById('filters').classList.remove('hide');
            document.getElementById('filters').classList.add('filters');
            document.getElementById('file_choise').classList.add('hide');
            tableCPU = JSON.parse(tableJSON);
            if (tableCPU.length > 0) {
                getOriginalCPU_Fields(tableCPU[0]);
                extendTable();
                renderNew(renderTypes.all);
            }
        }


        function getOriginalCPU_Fields(element) {
            tableCPU_Fields = Object.keys(element);
        }


        function sortTable() {
            tableCPU.sort(function (a, b) {
                return a.NUMMER - b.NUMMER;
            });
        }


        function sortTableLaeppdorntermin() {
            tableCPU.sort(function (a, b) {
                return new Date(a.LAEPPDATE).getTime() - new Date(b.LAEPPDATE).getTime();
            });
        }


        function sortTableRohlingstermin() {
            tableCPU.sort(function (a, b) {
                return new Date(a.ROHTEILDATE).getTime() - new Date(b.ROHTEILDATE).getTime();
            });
        }


        function sortTableBelegtermin() {
            tableCPU.sort(function (a, b) {
                return new Date(a.BELEGDATE).getTime() - new Date(b.BELEGDATE).getTime();
            });
        }


        function extendTable() {
            for (let index = 0; index < tableCPU.length; index++) {
                const element = tableCPU[index];
                extendABMESSUNG(element);
                extendSTATUS(element);
                extendKENNWORT(element);
                extendNENNDURCHMESSER_STEIGUNG(element);
                extendLAEPPDORN_RawMaterial(element);
                extendLaeppBohr(element);
                element['LAEPPDATE'] = getDateFromGER(element['T_LAEPP']);
                element['ROHTEILDATE'] = getDateFromGER(element['T_R']);
                element['BELEGDATE'] = new Date(element['BELEGDATUM']);
                extendROHTEIL_KW(element);
            }
        }


        function extendROHTEIL_KW(element) {
            element.ROHTEILWOCHE = getWeekNumber(element.ROHTEILDATE);
        }


        function getWeekNumber(sourceDate) {
            let date = new Date(sourceDate);
            let dayNum = date.getUTCDay() - 3;
            if (dayNum < 0) dayNum += 7;
            date.setUTCDate(date.getUTCDate() + 4 - dayNum);
            let yearStart = new Date(Date.UTC(date.getUTCFullYear(), 0, 1));
            return Math.ceil((((date - yearStart) / 86400000) + 1) / 7) - 1;
        };


        function extendLaeppBohr(element) {
            if (element['threadPropertys']) {
                let thProp = element.threadPropertys;
                if (thProp['diameter'] && thProp['pitch']) {
                    let bohrer = thProp.diameter - (2 * thProp.pitch);
                    if (thProp.diameter > 20) bohrer -= 5;
                    else bohrer -= 3;
                    element.LDBOHRDURCHMESSER = bohrer.toFixed(2);
                }
            }
        }


        function extendKENNWORT(element) {
            element.KENNWORT_CPU = element['KENNWORT'];
        }


        function extendSTATUS(element) {
            const tableKennwort = {
                "S L LD H R": "Rohlinge",
                "S L LD H": "Härterei",
                "S L LD": "Läppdorne",
                "S L": "Läppen",
                "S": "Schleifen",
            };
            if (tableKennwort[element['KENNWORT']]) {
                element['STATUS'] = tableKennwort[element['KENNWORT']];
            } else {
                element['STATUS'] = '-?-';
            }
        }


        function extendABMESSUNG(element) {
            const realRohteilDiameters = ['22', '32', '38', '45', '53', '63', '71',];
            if (element['ABMESSUNG']) {
                const abmessung = element['ABMESSUNG'];
                if (abmessung[0] == '�') {
                    const rohteilStrings = element['ABMESSUNG'].split(' ');
                    if (rohteilStrings.length > 0 && realRohteilDiameters.includes(rohteilStrings[1])) {
                        element.ROHTEILDURCHMESSER = '&Oslash;' + rohteilStrings[1];
                        element.ABMESSUNG_PUR = abmessung.substring(abmessung.indexOf(' ', 3) + 1);
                    } else {
                        element.ROHTEILDURCHMESSER = '&Oslash;' + abmessung.substring(1, abmessung.indexOf(' '));
                        if (element.ROHTEILDURCHMESSER.length == 8 || element.ROHTEILDURCHMESSER.length == 9) element.ROHTEILDURCHMESSER = '';
                        element.ABMESSUNG_PUR = abmessung.substring(abmessung.indexOf(' ') + 1);
                    }
                }
            }
        }


        const threatPitchM = {
            4: 0.7,
            4.5: 0.75,
            5: 0.8,
            6: 1,
            7: 1,
            8: 1.25,
            9: 1.25,
            10: 1.5,
            11: 1.5,
            12: 1.75,
            14: 2,
            16: 2,
            18: 2.5,
            20: 2.5,
            22: 2.5,
            24: 3,
            27: 3,
            30: 3.5,
            33: 3.5,
            36: 4,
            39: 4,
        }


        const threatPitchRG = {
            "1/16": 0.907,
            "1/8": 0.907,
            "1/4": 1.337,
            "3/8": 1.337,
            "1/2": 1.814,
            "5/8": 1.814,
            "3/4": 1.814,
            "7/8": 1.814,
            "1": 2.309,
        }


        const threatDiameterRG = {
            "1/16": 6.84,
            "1/8": 9.73,
            "1/4": 13.16,
            "3/8": 16.66,
            "1/2": 20.95,
            "5/8": 22.91,
            "3/4": 26.44,
            "7/8": 30.20,
            "1": 33.25,
        }


        function getThreadPropertys(abmessung) {
            //------------------------------------------------------------------------------------------------------------------------
            function getSubstrHS(text) { let pos = text.search(/[\s-]/); if (pos == -1) return text; return text.substring(0, pos); }
            function getSubstrMinus(text) { let pos = text.search(/[-]/); if (pos == -1) return text; return text.substring(0, pos); }
            function getSubstrX(text) { let pos = text.search(/[x]/); if (pos == -1) return text; return text.substring(0, pos); }
            //------------------------------------------------------------------------------------------------------------------------
            let threadPropertys = new Object();
            const astr = abmessung.trim();
            threadPropertys.type = astr.substring(0, astr.indexOf(' '));
            if (threadPropertys.type.startsWith('UN')) threadPropertys.type = 'UN';
            if (threadPropertys.type.startsWith('BS')) threadPropertys.type = 'BS';
            if (threadPropertys.type.startsWith('M')) threadPropertys.type = 'M';
            let propertyStr = astr.substring(astr.indexOf(' ')).trim();
            //------------------------------------------------------------------------------------------------------------------------
            // unbekanntes Gewinde
            if (/[0-9]/.test(threadPropertys.type[0])) { return undefined; }
            //------------------------------------------------------------------------------------------------------------------------
            // Pg
            // Fg
            // BS
            // FÜR BS geht vielleicht auch UN
            //------------------------------------------------------------------------------------------------------------------------
            if (threadPropertys.type == 'UN') {
                let propertySubString = getSubstrMinus(propertyStr);
                if (propertySubString.includes('/')) {
                    let factors = propertySubString.trim().split('/');
                    if (factors.length > 1) {
                        let firstFac = +factors[0];
                        let secondFac = +factors[1];
                        if (factors[0].includes(' ')) {
                            let firstFactors = factors[0].split(' ');
                            firstFac = +firstFactors[1];
                            if (firstFactors[0] == '1') firstFac += secondFac;
                            if (firstFactors[0] == '2') firstFac += secondFac * 2;
                        }
                        threadPropertys.diameter = (25.4 / secondFac * firstFac).toFixed(2);
                    }
                }
                else if (propertySubString == '1') threadPropertys.diameter = 25.4;
                else if (propertySubString.startsWith('0.') || propertySubString.startsWith('1.')) {
                    threadPropertys.diameter = (25.4 / parseFloat(propertySubString)).toFixed(2);
                }
                else return undefined;
                propertySubString = getSubstrHS(propertyStr.substring(propertyStr.indexOf('-') + 1));
                threadPropertys.pitch = (25.4 / propertySubString).toFixed(4);
            }
            else if (threadPropertys.type == 'R' || threadPropertys.type == 'G') {
                let propertySubString = getSubstrHS(propertyStr);
                if (threatDiameterRG[propertySubString]) threadPropertys.diameter = threatDiameterRG[propertySubString];
                else threadPropertys.diameter = '-?-';
                if (threatPitchRG[propertySubString]) threadPropertys.pitch = threatPitchRG[propertySubString];
                else threadPropertys.pitch = '-?-';
            }
            else if (threadPropertys.type == 'M' || threadPropertys.type == 'Tr') {
                propertyStr = propertyStr.replaceAll(',', '.');
                if (propertyStr.includes('x')) {
                    threadPropertys.diameter = getSubstrX(propertyStr);
                    threadPropertys.pitch = getSubstrHS(propertyStr.substring(propertyStr.indexOf('x') + 1));
                }
                else {
                    let propertySubString = getSubstrHS(propertyStr);
                    if (threatPitchM[propertySubString]) threadPropertys.pitch = threatPitchM[propertySubString];
                    else threadPropertys.pitch = '-?-';
                    threadPropertys.diameter = propertySubString;
                }
            }
            else return undefined;
            return threadPropertys;
        }


        function extendNENNDURCHMESSER_STEIGUNG(element) {
            if (element.ABMESSUNG_PUR) {
                setGewindeTypePropertys(element, getThreadPropertys(element.ABMESSUNG_PUR));
            }
        }


        function setGewindeTypePropertys(element, propertys) {
            if (propertys) {
                element.threadPropertys = propertys;
                element.GEWINDETYPE = propertys.type;
                element.NENNDURCHMESSER = propertys.diameter ? +propertys.diameter : '??';
                element.STEIGUNG = propertys.pitch ? +propertys.pitch : '??';
            }
            else {
                element.GEWINDETYPE = '???';
                element.NENNDURCHMESSER = '??';
                element.STEIGUNG = '??';
            }
        }


        function extendLAEPPDORN_RawMaterial(element) {
            if (element['threadPropertys'] && element.threadPropertys['diameter']) {
                element.LDROHDURCHMESSER = 'Klein';
                if (element.threadPropertys.diameter >= 24.8) element.LDROHDURCHMESSER = 'Mittel';
                if (element.threadPropertys.diameter >= 34.8) element.LDROHDURCHMESSER = 'Groß';
            }
            else element.LDROHDURCHMESSER = '?';
        }


        function getDateFromGER(dateString) {
            const dateStrings = dateString.split('.');
            if (dateStrings.length > 2) {
                if (dateStrings[2].length == 2) datestrings[2] = '20' + datestrings[2];
                return new Date(+dateStrings[2], +dateStrings[1] - 1, +dateStrings[0]);
            }
            return new Date('2022', '0', '1');
        }

        function isFieldsEqualArray(element, fields, values) {
            let equal = [];
            for (let index = 0; index < fields.length; index++) {
                const field = fields[index];
                const value = values[index];
                equal.push(element[field] == value);
            }
            return equal.includes(false) ? false : true;
        }

        function isFieldEqual(element, field, value) {
            return element[field] ? element[field] == value : false;
        }

        function isFieldNotEqualArray(element, field, noTypes) {
            return !noTypes.includes(element[field]);
        }

        function renderListType(listType) {
            document.getElementById('list_type').innerHTML = listType;
        }


        function renderShowLines(lineCounter) {
            document.getElementById('num_filter').innerHTML = `${lineCounter} von ${tableCPU.length} Aufträgen`;
        }


        function renderTableHeadline(tableHeadKeys) {
            let headerContent = '';
            for (let index = 0; index < tableHeadKeys.length; index++) {
                headerContent += `<th>${tableHeaderStrings[tableHeadKeys[index]]}</th>`;
            }
            return `<tr>${headerContent}</tr>`;
        }

        const specialFieldRenderer = {
            "KENNWORT": renderKENNWORT,
            "NUMMER": renderNUMMER,
            "ABMESSUNG_PUR": renderABMESSUNG,
            "LDBOHRDURCHMESSER": renderLDBohr,
            "LDROHDURCHMESSER": renderLDRoh,
            "GEWINDETYPE": renderGewType,
        }


        function renderGewType(index, element) {
            let type = element.GEWINDETYPE ? element.GEWINDETYPE : '';
            let content = type;
            if (type == '???') {
                content = `<button onClick="openGewindeChangeDialog(${index})" style="background-color: orange;">${type}</button>`
            }
            return `<td>${content}</td>`;
        }


        function openGewindeChangeDialog(index) {
            editGT_ID = index;
            document.getElementById('gewinde_type').value = '';
            document.getElementById('gewinde_diameter').value = '';
            document.getElementById('gewinde_pitch').value = '';
            document.getElementById('changegewindetype').classList.remove('hide');
        }


        function changeGT_cancel() {
            editGT_ID = -1;
            document.getElementById('changegewindetype').classList.add('hide');
        }


        function changeGT_confirm() {
            let gType = document.getElementById('gewinde_type').value;
            let gDiameter = document.getElementById('gewinde_diameter').value;
            let gPitch = document.getElementById('gewinde_pitch').value;
            if (gType && gDiameter && gPitch) {
                let newThreadProperty = new Object();
                newThreadProperty.type = gType;
                newThreadProperty.diameter = gDiameter;
                newThreadProperty.pitch = gPitch;
                let element = tableCPU[editGT_ID];
                setGewindeTypePropertys(element, newThreadProperty);
                extendLAEPPDORN_RawMaterial(element);
                extendLaeppBohr(element);
                if (lastRenderType) renderNew(lastRenderType);
                else renderFilterAndStoreTheFunction(filterAlle);
                editGT_ID = -1;
                document.getElementById('changegewindetype').classList.add('hide');
            }
            else {
                alert('Bitte alles ausfüllen');
            }
        }


        function renderLDRoh(index, element) {
            let innerHtml = element.LDROHDURCHMESSER;
            let action = '';
            if (element.LDROHDURCHMESSER == '?') innerHtml = getLDRohSelect(index);
            else action = `onClick="setLDRohUnknow(${index})"`;
            return `<td ${action} style="${getColorLDRohDiameter(element.LDROHDURCHMESSER)};${action == '' ? '' : 'cursor: pointer;'}">${innerHtml}</td>`;
        }


        function getColorLDRohDiameter(tag) {
            let color = 'orange';
            if (tag == 'Mittel') color = 'yellow';
            else if (tag == 'Groß') color = 'red';
            else if (tag == 'Klein') color = 'green';
            return `background-color: ${color};`;
        }


        function getLDRohSelect(index) {
            return `
            <label for="select_roh_diameter_${index}">Roh...</label>
                <select onchange="changeLDRohSelect(${index})" id="select_roh_diameter_${index}" name="select_roh_diameter_${index}">
                    <option value="?">?</option>
                    <option value="Klein">Klein</option>
                    <option value="Mittel">Mittel</option>
                    <option value="Groß">Groß</option>
                </select>
            `
        }


        function setLDRohUnknow(index) {
            const element = tableCPU[index];
            element.LDROHDURCHMESSER = '?';
            renderNew(lastRenderType);
        }


        function changeLDRohSelect(index) {
            const element = tableCPU[index];
            const newLDRoh = document.getElementById('select_roh_diameter_' + index).value;
            element.LDROHDURCHMESSER = newLDRoh;
            renderNew(lastRenderType);
        }


        function renderNUMMER(index, element) {
            let color = '';
            if (element['ZU_AUFTRAG']) {
                if (element.ZU_AUFTRAG == '00000000') color = 'background-color: rgb(255, 168, 168);';
                else color = 'background-color: rgb(92, 238, 92);';
            }
            if (element['HINWEISTEXT'] && element.HINWEISTEXT.includes('EXPRESS')) color = 'background-color: rgb(141, 141, 255);';
            return `<td style="${color}">${element.NUMMER}</td>`;
        }


        const tableKENNWORTconditions = [
            "",
            "S",
            "S L",
            "S L LD",
            "S L LD H",
            "S L LD H R",
        ]


        function removeTagFromKENNWORT(tableElement, index) {
            const element = tableCPU[index];
            const kennwort = element.KENNWORT;
            if (tableKENNWORTconditions.includes(kennwort)) {
                let currentIndex = tableKENNWORTconditions.findIndex((e) => { return kennwort == e; });
                if (currentIndex > 0) {
                    currentIndex--;
                    element.KENNWORT = tableKENNWORTconditions[currentIndex];
                    document.getElementById('kennwort_' + index).innerHTML = renderKENNWORT(index, element);
                }
            }
        }


        function addTagFromKENNWORT(tableElement, index) {
            const element = tableCPU[index];
            const kennwort = element.KENNWORT;
            if (tableKENNWORTconditions.includes(kennwort)) {
                let currentIndex = tableKENNWORTconditions.findIndex((e) => { return kennwort == e; });
                if (currentIndex < tableKENNWORTconditions.length - 1) {
                    currentIndex++;
                    element.KENNWORT = tableKENNWORTconditions[currentIndex];
                    document.getElementById('kennwort_' + index).innerHTML = renderKENNWORT(index, element);
                }
            }
        }


        function renderABMESSUNG(index, element) {
            return `<td style="text-align: left;padding-left: 10px;">${element.ABMESSUNG_PUR ? element.ABMESSUNG_PUR : ''}</td>`;
        }


        function renderLDBohr(index, element) {
            return `<td style="text-align: left;padding-left: 5px;">${element.LDBOHRDURCHMESSER ? element.LDBOHRDURCHMESSER : ''}</td>`;
        }


        function renderKENNWORT(index, element) {
            let fieldKENNWORT = element.KENNWORT;
            let currentIndex = tableKENNWORTconditions.findIndex((e) => { return fieldKENNWORT == e; });
            let fieldHTML = fieldKENNWORT;
            if (currentIndex > 0) fieldHTML += `<button onClick="removeTagFromKENNWORT(this,${index})">&#x2770;</button>`;
            if (currentIndex < tableKENNWORTconditions.length - 1) fieldHTML += `<button onClick="addTagFromKENNWORT(this,${index})">&#x2771;</button>`;
            return `<td style="text-align: left;" id="kennwort_${index}">${fieldHTML}</td>`;
        }


        function renderDefault(fieldValue) {
            return `<td>${fieldValue}</td>`;
        }


        let renderGroupingState = 0;
        let lastGroupingIndex = -1;
        const renderGroupingColors = ['lightgray', 'white'];

        function renderGrouping(index, field) {
            if (lastGroupingIndex >= 0 && (tableCPU[lastGroupingIndex][field] != tableCPU[index][field])) {
                renderGroupingState = +!renderGroupingState;
            }
            lastGroupingIndex = index;
            return `<td style="background-color:${renderGroupingColors[renderGroupingState]}">${tableCPU[index][field]}</td>`;
        }


        function renderTableLine(index, element, tableHeadKeys) {
            let rowContent = '';
            for (let x = 0; x < tableHeadKeys.length; x++) {
                const key = tableHeadKeys[x];
                const fieldValue = element[key] ? element[key] : '';
                if (specialFieldRenderer[key]) rowContent += specialFieldRenderer[key](index, element);
                else if (lastRenderType['grouping_key'] && lastRenderType['grouping_key'] == key) rowContent += renderGrouping(index, key);
                else rowContent += renderDefault(fieldValue);
            }
            return `<tr id="line_${index}">${rowContent}</tr>`
        }


        function printList() {
            window.print();
        }

        const sorters = {
            fa_number: function (a, b) {
                return a.NUMMER - b.NUMMER;
            },
            diameter_rohteil: function (a, b) {
                let aRDM = a['ROHTEILDURCHMESSER'] ? a.ROHTEILDURCHMESSER : '';
                let bRDM = b['ROHTEILDURCHMESSER'] ? b.ROHTEILDURCHMESSER : '';
                return aRDM.localeCompare(bRDM);
            },
            nenndurchmesser: function (a, b) {
                function getNDM(ndmString) { if (ndmString != undefined && ndmString != '??') return +ndmString; return 0; }
                if (a.NENNDURCHMESSER == 5 || b.NENNDURCHMESSER == 5) {
                    console.log('debug');
                }
                let aNDM = getNDM(a.NENNDURCHMESSER);
                let bNDM = getNDM(b.NENNDURCHMESSER);
                if (aNDM > bNDM) return 1;
                else if (aNDM < bNDM) return -1;
                return 0;
            },
            date_laepp: function (a, b) {
                return new Date(a.LAEPPDATE).getTime() - new Date(b.LAEPPDATE).getTime();
            },
            date_rohling: function (a, b) {
                return new Date(a.ROHTEILDATE).getTime() - new Date(b.ROHTEILDATE).getTime();
            },
            date_beleg: function (a, b) {
                return new Date(a.BELEGDATE).getTime() - new Date(b.BELEGDATE).getTime();
            },
        };

        const button_groups = {
            kennwort: 'Filtern nach Kennwort',
            gewindeart: 'Filtern nach Gewindeart',
        };

        const renderTypes = {
            'all': {
                'group': 'kennwort',
                'sort': 'date_beleg',
                'info': 'Alle Aufträge',
                'buttonText': 'Alle Aufträge',
                'tablekeys': tableViewAllKeys,
                'filters': [
                    {
                        function: undefined,
                        'field': '',
                        'value': ''
                    }
                ]
            },
            'roh': {
                'group': 'kennwort',
                // sort
                'sort': 'date_rohling',
                // info setzen
                'info': 'Alle Rohlingsaufträge',
                'buttonText': 'Rohlinge',
                // tabelle rendern
                'tablekeys': tableViewRohteilKeys,
                'grouping_key': 'ROHTEILWOCHE',
                'filters': [
                    {
                        function: isFieldEqual,
                        'field': 'KENNWORT',
                        'value': 'S L LD H R'
                    }
                ]
            },
            'rohrm': {
                'group': 'kennwort',
                // sort
                'sort': 'diameter_rohteil',
                // info setzen
                'info': 'Alle Rohlingsaufträge nach Rohlingsdurchmesser',
                'buttonText': 'Rohlinge RD',
                // tabelle rendern
                'tablekeys': tableViewRohteilKeys,
                'grouping_key': 'ROHTEILDURCHMESSER',
                'filters': [
                    {
                        function: isFieldEqual,
                        'field': 'KENNWORT',
                        'value': 'S L LD H R'
                    }
                ]
            },
            'rohweek': {
                'group': 'kennwort',
                // sort
                'sort': 'diameter_rohteil',
                // info setzen
                'info': 'Alle Rohlingsaufträge nach Roh&Oslash; und Woche',
                'buttonText': 'Rohlinge RD&W',
                // tabelle rendern
                'tablekeys': tableViewRohteilKeys,
                'filters': [
                    {
                        function: isFieldEqual,
                        'field': 'KENNWORT',
                        'value': 'S L LD H R'
                    }
                ],
                'renderFunction': renderRohDMWeek,
            },
            'hart': {
                'group': 'kennwort',
                // sort
                'sort': 'date_rohling',
                // info setzen
                'info': 'Alle Aufträge in der Härterei',
                'buttonText': 'Härterei',
                // tabelle rendern
                'tablekeys': tableViewAllKeys,
                'filters': [
                    {
                        function: isFieldEqual,
                        'field': 'KENNWORT',
                        'value': 'S L LD H'
                    }
                ]
            },
            'laeppd': {
                'group': 'kennwort',
                // sort
                'sort': 'date_laepp',
                // info setzen
                'info': 'Alle Aufträge zum Läppdorndrehen',
                'buttonText': 'Läppdorne',
                // tabelle rendern
                'tablekeys': tableViewLaeppdornKeys,
                'filters': [
                    {
                        function: isFieldEqual,
                        'field': 'KENNWORT',
                        'value': 'S L LD'
                    }
                ]
            },
            'laeppdrm': {
                'group': 'kennwort',
                // sort
                'sort': 'date_laepp',
                // info setzen
                'info': 'Alle Aufträge zum Läppdorndrehen nach Rohteildurchmesser',
                'buttonText': 'Läppdorne RM',
                // tabelle rendern
                'tablekeys': tableViewLaeppdornKeys,
                'filters': [
                    {
                        function: isFieldsEqualArray,
                        'field': ['KENNWORT', 'LDROHDURCHMESSER'],
                        'value': ['S L LD', 'Klein']
                    },
                    {
                        function: isFieldsEqualArray,
                        'field': ['KENNWORT', 'LDROHDURCHMESSER'],
                        'value': ['S L LD', 'Mittel']
                    },
                    {
                        function: isFieldsEqualArray,
                        'field': ['KENNWORT', 'LDROHDURCHMESSER'],
                        'value': ['S L LD', 'Groß']
                    },
                    {
                        function: isFieldsEqualArray,
                        'field': ['KENNWORT', 'LDROHDURCHMESSER'],
                        'value': ['S L LD', '?']
                    },
                ]
            },
            'laepp': {
                'group': 'kennwort',
                // sort
                'sort': 'date_laepp',
                // info setzen
                'info': 'Alle Aufträge zum Läppen',
                'buttonText': 'Läppen',
                // tabelle rendern
                'tablekeys': tableViewLaeppKeys,
                'filters': [
                    {
                        function: isFieldEqual,
                        'field': 'KENNWORT',
                        'value': 'S L'
                    }
                ]
            },
            'schleif': {
                'group': 'kennwort',
                // sort
                'sort': 'date_beleg',
                // info setzen
                'info': 'Alle Aufträge beim Schleifen',
                'buttonText': 'Schleifen',
                // tabelle rendern
                'tablekeys': tableViewAllKeys,
                'filters': [
                    {
                        function: isFieldEqual,
                        'field': 'KENNWORT',
                        'value': 'S'
                    }
                ]
            },
            'type_m': {
                'group': 'gewindeart',
                // sort
                'sort': 'date_beleg',
                // info setzen
                'info': 'Alle Aufträge mit Metrischen Gewinde',
                'buttonText': 'Metrisch',
                // tabelle rendern
                'tablekeys': tableViewAllKeys,
                'filters': [
                    {
                        function: isFieldEqual,
                        'field': 'GEWINDETYPE',
                        'value': 'M'
                    }
                ]
            },
            'type_m_ndm': {
                'group': 'gewindeart',
                // sort
                'sort': 'nenndurchmesser',
                // info setzen
                'info': 'Alle Aufträge mit Metrischen Gewinde nach Nenn &Oslash;',
                'buttonText': 'Metrisch nach &Oslash;',
                // tabelle rendern
                'tablekeys': tableViewAllKeys,
                'grouping_key': 'NENNDURCHMESSER',
                'filters': [
                    {
                        function: isFieldEqual,
                        'field': 'GEWINDETYPE',
                        'value': 'M'
                    }
                ]
            },
            'type_un': {
                'group': 'gewindeart',
                // sort
                'sort': 'date_beleg',
                // info setzen
                'info': 'Alle Aufträge mit Un Gewinde',
                'buttonText': 'UN...',
                // tabelle rendern
                'tablekeys': tableViewAllKeys,
                'filters': [
                    {
                        function: isFieldEqual,
                        'field': 'GEWINDETYPE',
                        'value': 'UN'
                    }
                ]
            },
            'type_tr': {
                'group': 'gewindeart',
                // sort
                'sort': 'date_beleg',
                // info setzen
                'info': 'Alle Aufträge mit Trapez Gewinde',
                'buttonText': 'Trapez',
                // tabelle rendern
                'tablekeys': tableViewAllKeys,
                'filters': [
                    {
                        function: isFieldEqual,
                        'field': 'GEWINDETYPE',
                        'value': 'Tr'
                    }
                ]
            },
            'type_g': {
                'group': 'gewindeart',
                // sort
                'sort': 'date_beleg',
                // info setzen
                'info': 'Alle Aufträge mit G Gewinde',
                'buttonText': 'G',
                // tabelle rendern
                'tablekeys': tableViewAllKeys,
                'filters': [
                    {
                        function: isFieldEqual,
                        'field': 'GEWINDETYPE',
                        'value': 'G'
                    }
                ]
            },
            'type_r': {
                'group': 'gewindeart',
                // sort
                'sort': 'date_beleg',
                // info setzen
                'info': 'Alle Aufträge mit R Gewinde',
                'buttonText': 'R',
                // tabelle rendern
                'tablekeys': tableViewAllKeys,
                'filters': [
                    {
                        function: isFieldEqual,
                        'field': 'GEWINDETYPE',
                        'value': 'R'
                    }
                ]
            },
            'type_other': {
                'group': 'gewindeart',
                // sort
                'sort': 'date_beleg',
                // info setzen
                'info': 'Alle Aufträge mit anderen Gewinde',
                'buttonText': 'Andere',
                // tabelle rendern
                'tablekeys': tableViewAllKeys,
                'filters': [
                    {
                        function: isFieldNotEqualArray,
                        'field': 'GEWINDETYPE',
                        'value': ['UN', 'Tr', 'M', 'G', 'R',]
                    }
                ]
            },
        }


        let showLinesWeek = 0;


        function renderWeekCellInfo(week, rohDM, minrohDM) {
            function isRohteilState(element) { return element.KENNWORT == 'S L LD H R'; }
            function isRohteilWeek(element, week) { return element.ROHTEILWOCHE == week; }
            function isRohteilDM(element, diameter) { return element.ROHTEILDURCHMESSER ? element.ROHTEILDURCHMESSER == `&Oslash;${diameter}` : false; }
            function isRohteilDMRange(element, diameter, mindiameter) {
                const pureDiameter = element.ROHTEILDURCHMESSER ? +element.ROHTEILDURCHMESSER.substring(8) : 0;
                return pureDiameter <= diameter && pureDiameter > mindiameter;
            }
            let faLager = 0;
            let faKunde = 0;
            let cellColor = 'white';
            let cellTitle = '';
            for (let index = 0; index < tableCPU.length; index++) {
                const element = tableCPU[index];
                if (isRohteilState(element) && isRohteilWeek(element, week) && isRohteilDMRange(element, rohDM, minrohDM)) {
                    if (element.ZU_AUFTRAG == '00000000' || element.ZU_AUFTRAG == '') {
                        faLager++;
                        showLinesWeek++;
                    } else {
                        faKunde++;
                        showLinesWeek++;
                        cellTitle += element.NUMMER + ' -> ' + element.ABMESSUNG_PUR + '\n';
                    }
                }
            }
            if (faKunde > 0) cellColor = 'lightgreen';
            else if (faLager > 0) cellColor = 'lightpink';
            return `<td title="${cellTitle}" style="background-color: ${cellColor}">${faKunde > 0 ? faKunde : ' '} ${faLager > 0 ? '(' + faLager + ')' : ' '}</td>`;
        }


        function renderRohDMWeek() {
            const renderRows = ['0', '22', '32', '38', '45', '53', '63', '71',];
            const maxWeekShows = 5;
            let currentWeek = getWeekNumber(new Date(Date.now())) - 2;
            let tabelInnerHTML = '';
            showLinesWeek = 0;

            for (let index = 0; index < renderRows.length; index++) {
                const rohDM = renderRows[index];
                let headRow = '';
                let firstCell = '';
                if (rohDM == '0') firstCell = '<th></th>';
                else firstCell = `<td>&Oslash;${rohDM}</td>`;
                for (let week = currentWeek; week < currentWeek + maxWeekShows; week++) {
                    if (rohDM == '0') {
                        headRow += `<th>${week}</th>`;
                    } else {
                        headRow += renderWeekCellInfo(week, rohDM, renderRows[index - 1]);
                    }
                }
                tabelInnerHTML += `<tr>${firstCell}${headRow}</tr>`;
            }
            document.getElementById('list_content').innerHTML = `<table><tbody class="table_week">${tabelInnerHTML}</tbody></table>`;
            return showLinesWeek;
        }


        function renderTableDefault(renderOpt) {
            let showLines = 0;
            let inputDIV = document.getElementById('list_content')
            let tabelInnerHTML = renderTableHeadline(renderOpt['tablekeys']);
            for (let f = 0; f < renderOpt.filters.length; f++) {
                const filter = renderOpt.filters[f];
                for (let i = 0; i < tableCPU.length; i++) {
                    const element = tableCPU[i];
                    if (!filter.function || filter.function(element, filter.field, filter.value)) {
                        showLines++;
                        tabelInnerHTML += renderTableLine(i, element, renderOpt['tablekeys']);
                    }
                }
            }
            inputDIV.innerHTML = `<table><tbody class="table_main">${tabelInnerHTML}</tbody></table>`;
            return showLines;
        }


        function renderNew(renderOpt) {
            lastRenderType = renderOpt;
            lastGroupingIndex = -1;
            renderGroupingState = 0;
            tableCPU.sort(sorters[renderOpt.sort]);
            renderListType(renderOpt['info']);
            let showLines = 0;
            if (renderOpt['renderFunction']) showLines = renderOpt.renderFunction(renderOpt);
            else showLines = renderTableDefault(renderOpt);
            renderShowLines(showLines);
        }


        function renderButtons() {
            let buttonBar = document.getElementById('button_bar_left');
            let renderKeys = Object.keys(renderTypes);
            let buttonGroupKeys = Object.keys(button_groups);
            for (let x = 0; x < buttonGroupKeys.length; x++) {
                const group = buttonGroupKeys[x];
                buttonBar.innerHTML += `<span>${button_groups[group]}</span>`;
                for (let i = 0; i < renderKeys.length; i++) {
                    const renderType = renderTypes[renderKeys[i]];
                    if (renderType.group == group) {
                        buttonBar.innerHTML += `
                        <button onclick="renderNew(renderTypes['${renderKeys[i]}'])">${renderType.buttonText}</button>
                        `;
                    }
                }
            }
        }

    </script>
</head>

<body onload="renderButtons()">
    <div id="file_choise" class="file_choise">
        <input type="file" name="Lade Tabelle" id="cpu_file" accept=".json" onchange="loadTable(this)">
    </div>
    <div id="filters" class="hide">
        <div id="button_bar_left" class="button_bar_left">
            <button onclick="printList()">Drucken</button>
        </div>
        <div class="filter_infos">
            <span class="list_type" id="list_type"></span>
            <span id="lastModifiedDate"></span>
            <span id="num_filter"></span>
        </div>
    </div>
    <div id="list_content" class="list_content"></div>
    <div id="changegewindetype" class="changegewindetype hide">
        <div class="change_gt_innerbox">
            <div class="change_gt_box">
                <h2>Gewindetype ändern</h2>
                <label for="gewinde_type">Gewindetype</label>
                <select id="gewinde_type" name="gewinde_type">
                    <option value="M">Metrisch</option>
                    <option value="UN">UN</option>
                    <option value="Tr">Trapez</option>
                    <option value="R">R</option>
                    <option value="FG">FG</option>
                    <option value="Pg">Pg</option>
                    <option value="ACME">ACME</option>
                    <option value="W">W</option>
                </select>
                <label for="gewinde_diameter">Gewinde Nenndurchmesser</label>
                <input type="number" name="gewinde_diameter" id="gewinde_diameter">
                <label for="gewinde_pitch">Gewinde Steigung</label>
                <input type="number" name="gewinde_pitch" id="gewinde_pitch">
                <span>___________________________________________________</span>
                <div class="change_gt_actions">
                    <button onclick="changeGT_cancel()">Cancel</button>
                    <button onclick="changeGT_confirm()">OK</button>
                </div>
            </div>
        </div>
    </div>
</body>

</html>